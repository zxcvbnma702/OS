
## 参考书籍

[《x86汇编语言：从实模式到保护模式（第2版）》]()
[《操作系统真相还原》]()

## Vscode插件

> Name: ASM Code Lens
Id: maziac.asm-code-lens
Description: A language server that enables code lens, references, hover information, symbol renaming and the outline view for assembler files.
Version: 2.6.0
Publisher: maziac
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=maziac.asm-code-lens

> Name: C/C++
Id: ms-vscode.cpptools
Description: C/C++ IntelliSense, debugging, and code browsing.
Version: 1.18.5
Publisher: Microsoft
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools

> Name: C/C++ Extension Pack
Id: ms-vscode.cpptools-extension-pack
Description: Popular extensions for C++ development in Visual Studio Code.
Version: 1.3.0
Publisher: Microsoft
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack

> Name: CMake Tools
Id: ms-vscode.cmake-tools
Description: Extended CMake support in Visual Studio Code
Version: 1.16.32
Publisher: Microsoft
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools

> Name: Hex Editor
Id: ms-vscode.hexeditor
Description: Allows viewing and editing files in a hex editor
Version: 1.9.12
Publisher: Microsoft
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.hexeditor

> Name: Markdown All in One
Id: yzhang.markdown-all-in-one
Description: All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more)
Version: 3.6.2
Publisher: Yu Zhang
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one

> Name: NASM Language Support
Id: doinkythederp.nasm-language-support
Description: Language features for NASM Assembly
Version: 1.2.0
Publisher: doinkythederp
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=doinkythederp.nasm-language-support

> Name: Remote - SSH: Editing Configuration Files
Id: ms-vscode-remote.remote-ssh-edit
Description: Edit SSH configuration files
Version: 0.86.0
Publisher: Microsoft
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh-edit

> Name: Remote - SSH: Editing Configuration Files
Id: ms-vscode-remote.remote-ssh-edit
Description: Edit SSH configuration files
Version: 0.86.0
Publisher: Microsoft
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh-edit

> Name: Makefile Tools
Id: ms-vscode.makefile-tools
Description: Provide makefile support in VS Code: C/C++ IntelliSense, build, debug/run.
Version: 0.8.22
Publisher: Microsoft
VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools

## 汇编

### nasm 编译命令
    nasm -f bin boot.asm -o boot.bin

### 条件转移指令

![Alt text](assets/image-5.png)

### ASCII表

![Alt text](assets/image-6.png)
![Alt text](assets/image-7.png)

## 开发环境配置

### GIT

[linux下连接github](https://www.cnblogs.com/woider/p/6533709.html)
[端口代理](https://ericclose.github.io/git-proxy-config.html)
[DNS污染解决](https://zhuanlan.zhihu.com/p/521340971)

### 创建硬盘镜像

> [When you run bximage without one of the following options, it will appear in interactive mode and ask for all required parameters to manipulate an image.](https://manpages.debian.org/testing/bximage/bximage.1.en.html)

> **-func=...**
Operation to perform (create, convert, resize, commit, info)
**-fd=...**
Create: floppy image with size code (e.g. 360k, 720k, 1.44M)
**-hd=...**
Create/resize: hard disk image with size in megabytes (M) or gigabytes (G)
**-imgmode=...**
Create/convert: hard disk image mode - see the bochsrc sample for supported options.
**-b**
Convert/resize: create a backup of the source image. Commit: create backups of base image and redolog file.
**-q**
Quiet mode (don't prompt for user input). Without this option bximage uses the command line parameters as defaults for the interactive mode. If this option is given and one of the required parameters is missing, bximage will fall back to interactive mode.
**--help**
Print a summary of the command line options for bximage and exit.

理论上命令按照上文引用, 实际操作命令建议使用``bximage --help``查看

创建硬盘镜像

    bximage -q -hd=16 -mode=create -imgmode=flat master.img

将 boot.bin 写入主引导扇区

    dd if=boot.bin of=master.img bs=512 count=1 conv=notrunc

### 配置 bochs

    ata0-master: type=disk, path="master.img", mode=flat

### bochsrc

```ini
# configuration file generated by Bochs
plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1
config_interface: textconfig
display_library: x, options="gui_debug"
memory: host=32, guest=32
romimage: file="/usr/local/share/bochs/BIOS-bochs-latest", address=0x0, options=none
vgaromimage: file="/usr/local/share/bochs/VGABIOS-lgpl-latest"
boot: disk
floppy_bootsig_check: disabled=0
# no floppya
# no floppyb
ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
ata0-master: type=disk, path="master.img", mode=flat
ata0-slave: type=none
ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
ata1-master: type=none
ata1-slave: type=none
ata2: enabled=0
ata3: enabled=0
optromimage1: file=none
optromimage2: file=none
optromimage3: file=none
optromimage4: file=none
optramimage1: file=none
optramimage2: file=none
optramimage3: file=none
optramimage4: file=none
pci: enabled=1, chipset=i440fx
vga: extension=vbe, update_freq=5, realtime=1
cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0
cpuid: level=6, stepping=3, model=3, family=6, vendor_string="GenuineIntel", brand_string="              Intel(R) Pentium(R) 4 CPU        "
cpuid: mmx=1, apic=xapic, simd=sse2, sse4a=0, misaligned_sse=0, sep=1, movbe=0, adx=0
cpuid: aes=0, sha=0, xsave=0, xsaveopt=0, smep=0, smap=0, mwait=1
print_timestamps: enabled=0
debugger_log: -
magic_break: enabled=0
port_e9_hack: enabled=0
private_colormap: enabled=0
clock: sync=none, time0=local, rtc_sync=0
# no cmosimage
# no loader
log: -
logprefix: %t%e%d
debug: action=ignore
info: action=report
error: action=report
panic: action=ask
keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none
mouse: type=ps2, enabled=0, toggle=ctrl+mbutton
speaker: enabled=1, mode=system
parport1: enabled=1, file=none
parport2: enabled=0
com1: enabled=1, mode=null
com2: enabled=0
com3: enabled=0
com4: enabled=0
```

## 实模式

### 8086寻址方式

实际地址 = 段地址 << 4 + 偏移地址

### 古老的INTEL 8086处理器

![Alt text](assets/image-4.png)

◆ 数据段可以起始于内存中的任何位置

◆ 为了让你写的程序在卖给别人之后，可以在内存中的任何地方正确执行，就只能在编写程序的时候使用相对地址或者逻辑地址，而不能使用真实的物理地址。当加载程序时，这些相对地址还要根据程序实际被加载的位置重新计算。

◆ 为了在硬件一级提供对“段地址:偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器(Code Segment, CS)和数据段寄存器(Data Segment, DS)。

◆ CS是代码段寄存器，DS是数据段寄存器，ES是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS指向一个，ES指向另一个。可以在指令中指定使用DS和ES中的哪一个，如果没有指定，则默认使用DS。SS是栈段(Stack Segment)寄存器

◆ IP是指令指针(Instruction Pointer)寄存器，它只和CS一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS保存代码段的段地址，IP则指向段内偏移。这样，由CS和IP共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改变IP的值，使它指向下一条指令。

◆ **段只能起始于那些能够被16整除的物理内存地址**。对8086处理器来说，将这样的内存地址除以16或者右移4位，得到的结果就是逻辑段地址，简称段地址。要访问一个段，需要将段地址传送到段寄存器。

◆ 每个段正好16字节，偏移地址从0000H到000FH。

◆ 同样在不允许段之间重叠的情况下，每个段的最大长度是64KB，因为偏移地址也是16位的，从0000H到FFFFH。在这种情况下，1MB的内存，最多只能划分成16个段，每段长64KB，段地址分别是0000H、1000H、2000H、3000H，…，F000H。

◆ 段地址的选择取决于内存中哪些区域是空闲的。举个例子来说，假如从物理地址00000H开始，一直到82251H处都被其他程序占用着，而后面一直到FFFFFH的地址空间都是自由的，那么，你可以从物理内存地址82251H之后的地方加载你的程序。

◆ **8086处理器的逻辑分段，起始地址都是16的倍数，这称为是按16字节对齐的**。

◆ 段的划分是自由的，它可以起始于任何16字节对齐的内存地址，也可以是任意长度，只要不超过64KB。

### 8086内存分布

![Alt text](assets/image.png)

### 主引导扇区

◆ 一个有效的主引导扇区，其最后2字节的数据必须是0x55和0xAA。

◆ 在INTEL处理器上，将一个字写入内存时，是采用低端字节序的，低字节0x55置入低地址端（在前），高字节0xAA置入高地址端（在后）。

## 显卡

◆ 8086可以访问1MB内存。其中，0x00000～9FFFF属于常规内存，由内存条提供；0xF0000～0xFFFFF由主板上的一个芯片提供，即ROM-BIOS。这样一来，中间还有一个320KB的空洞，即0xA0000～0xEFFFF。传统上，这段地址空间由特定的外围设备来提供，其中就包括显卡。

![Alt text](assets/image-8.png)

◆ 一直以来，0xB8000～0xBFFFF这段物理地址空间，是留给显卡的，由显卡来提供，用来显示文本。

◆ 为了访问显存，也需要使用逻辑地址，也就是采用“段地址:偏移地址”的形式，这是处理器的要求。考虑到文本模式下显存的起始物理地址是0xB8000，这块内存可以看成段地址为0xB800，偏移地址从0x0000延伸到0xFFFF的区域，因此我们可以把段地址定为0xB800。

### 字符颜色

◆ 屏幕上的每个字符对应着显存中连续2字节，前一个是字符的ASCII代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）。

◆ 字符的显示属性（1字节）分为两部分，低4位定义的是前景色，高4位定义的是背景色。色彩主要由R、G、B这3位决定，毕竟我们知道，可以由红(R)、绿(G)、蓝(B)三原色来配出其他所有颜色。K是闪烁位，为0时不闪烁，为1时闪烁；I是亮度位，为0时正常亮度，为1时呈高亮。表6-2给出了背景色和前景色的所有可能值。

![Alt text](assets/image-9.png)

## 硬盘

![Alt text](assets/image-1.png)

### 背景知识

◆ 在硬盘上，数据的访问是以柱面来组织的。

◆ ROM-BIOS将读取硬盘主引导扇区的内容，将它加载到内存地址0x0000:0x7c00（也就是物理地址0x07C00），然后用一个jmp指令跳到那里接着执行

◆ 物理地址0x0FFFF以下，是加载器及其栈的势力范围；物理地址A0000以上，是BIOS和外围设备的势力范围，有很多传统的老式设备将自己的存储器和只读存储器映射到这个空间。

◆ **输入输出控制设备集中器(I/O Controller Hub, ICH)芯片，该芯片的作用是连接不同的总线，并协调各个I/O接口对处理器的访问**。在个人计算机上，这块芯片就是所谓的南桥。

◆ 处理器通过局部总线连接到ICH内部的处理接口电路。然后，在ICH内部，又通过总线与各个I/O接口相连。在ICH内部，集成了一些常规的外围设备接口，如USB、PATA(IDE)、SATA、老式总线接口(LPC)、时钟等，这些东西对计算机来说必不可少，故直接集成在ICH内，我们后面还会详细介绍它们的功能。

◆ ICH还提供了对PCI或者PCI Express总线的支持，该总线向外延伸，连接着主板上的若干个扩展槽，就是刚才说的插槽。举个实例，如果你想连接显示器，那么就要先插入显卡，然后再把显示器接到显卡上。

◆ 处理器是通过端口(Port)来和外围设备打交道的。本质上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处仅仅在于，这些叫作端口的寄存器位于I/O接口电路中。

◆ PATA/SATA接口就有几个端口，分别是**命令端口**（当向该端口写入0x20时，表明是从硬盘读数据；写入0x30时，表明是向硬盘写数据）、**状态端口**（处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误）、**参数端口**（处理器通过这些端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号）和**数据端口**（通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据）。

◆ ICH芯片内部通常集成了两个PATA/SATA接口，分别是主硬盘接口和副硬盘接口。这样一来，主硬盘接口分配的端口号是0x1f0～0x1f7，副硬盘接口分配的端口号是0x170～0x177。

![Alt text](assets/image-10.png)

◆ 在INTEL的系统中，只允许65536（十进制数）个端口存在，端口号从0到65535(0x0000～0xffff)。因为是独立编址，所以，端口的访问不能使用类似于mov这样的指令，取而代之的是in和out指令。

◆ 硬盘读写的基本单位是扇区。就是说，要读就至少读一个扇区，要写就至少写一个扇区，不可能仅读写一个扇区中的几个字节。这样一来，就使得主机和硬盘之间的数据交换是成块的，所以硬盘是典型的**块设备**。

◆ 从硬盘读写数据，最经典的方式是向硬盘控制器分别发送磁头号、柱面号和扇区号（扇区在某个柱面上的编号），这称为**CHS模式**。

◆ 最早的逻辑扇区编址方法是LBA28，使用28比特来表示逻辑扇区号，从逻辑扇区0x0000000到0xFFFFFFF，共可以表示2`28=268435456个扇区。每个扇区有512字节，所以**LBA28可以管理128 GB的硬盘**。

◆ LBA48，采用48比特来表示逻辑扇区号。如此一来，就可以管理131072 TB的硬盘容量了。

◆ **个人计算机上的主硬盘控制器被分配了8位端口，端口号从0x1f0到0x1f7**。

### 硬盘读写

![Alt text](assets/image-10.png)

- 0x1F0：16bit 端口，用于读写数据
- 0x1F1：检测前一个指令的错误
- 0x1F2：读写扇区的数量
- 0x1F3：起始扇区的 0 ~ 7 位
- 0x1F4：起始扇区的 8 ~ 15 位
- 0x1F5：起始扇区的 16 ~ 23 位
- 0x1F6:
    - 0 ~ 3：起始扇区的 24 ~ 27 位
    - 4: 0 主盘, 1 从盘
    - 6: 0 CHS, 1 LBA
    - 5 ~ 7：固定为1
- 0x1F7: out
    - 0xEC: 识别硬盘
    - 0x20: 读硬盘
    - 0x30: 写硬盘
- 0x1F7: in / 8bit
    - 0 ERR
    - 3 DRQ 数据准备完毕
    - 7 BSY 硬盘繁忙

1. 第1步，设置要读取的扇区数量。这个数值要写入**0x1f2**端口。这是个8位端口，因此每次只能读写255个扇区
2. 第2步，设置起始LBA扇区号。扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。28位的扇区号太长，需要将其分成4段，分别写入端口``0x1f3、0x1f4、0x1f5 和 0x1f6``。其中，``0x1f3``号端口存放的是0～7位；0x1f4号端口存放的是8～15位；0x1f5号端口存放的是16～23位，最后4位在0x1f6号端口。

> 在现行的体系下，每个PATA/SATA接口允许挂接两块硬盘，分别是主盘(Master)和从盘(Slave)。如图所示，0x1f6端口的低4位用于存放逻辑扇区号的24～27位，第4位用于指示硬盘号，0表示主盘，1表示从盘。高3位是“111”，表示LBA模式。![Alt text](assets/image-3.png)

3. 第3步，向端口 ``0x1f7`` 写入0x20，请求硬盘读。
4. 第4步，等待读写操作完成。端口``0x1f7``既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将``0x1f7``端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。
5. 第5步，连续取出数据。``0x1f0``是硬盘接口的数据端口，而且还是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。

## 内存

### 内存检测

 > BIOS 0x15 中断提供了丰富的功能，具体要调用的功能，需要在寄存器 ax 中指定。其中 0xE8xx 系列的子功能较为强大，0x15 中断的子功能 0xE820 和 0xE801 都可以用来获取内存，区别是 0xE820 返回的是内存布局，信息量相对多一些，操作也相对复杂。而 0xE801 直接返回的是内存容量，操作适中，不繁不简。上面还提到了子功能 0x88 也能获取内存容量，这是最简单的用法，不过操作越简单，功能也就越薄弱。

#### 利用 BIOS 中断 0x15 子功能 0xe820 获取内存

> BIOS 中断 0x15 的子功能 0xE820 能够获取系统的内存布局，由于系统内存各部分的类型属性不同，BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。子功能 0xE820 的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符（Address Range Descriptor Structure，ARDS）

![alt text](assets/image-11.png)

> 此结构中的字段大小都是 4 字节，共 5 个字段，所以此结构大小为 20 字节。每次 int 0x15 之后，BIOS就返回这样一个结构的数据。注意，ARDS 结构中用 64 位宽度的属性来描述这段内存基地址（起始地址）及其长度，所以表中的基地址和长度都分为低 32 位和高 32 位两部分。 其中的 Type 字段用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，即其是可以被操作系统使用，还是保留起来不能用。

![alt text](assets/image-12.png)

由于我们在 32 位环境下工作，所以在 ARDS 结构属性中，我们只用到低 32 位属性。``BaseAddrLow+LengthLow``是一片内存区域上限，单位是字节。

#### 具体操作流程

1. 填写好“调用前输入”中列出的寄存器。 
2. 执行中断调用 int 0x15。 
3. 在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

![alt text](assets/image-13.png)

![alt text](assets/image-14.png)

## 用户程序

![用户程序头部结构](assets/image-2.png)

