《x86汇编语言：从实模式到保护模式（第2版）》

李忠 王晓波 余洁
61个笔记

第一十四章 2.3　具有记忆功能的器件——寄存器

◆ 如果需要，寄存器可以随时锁存新的数字，以前锁存的数字会被新的数字冲掉。从这个意义上来说，任何数字都是临时被保存在这里的，不会长久，属于临时性寄存。这就是“寄存器”一词的由来。


第一十八章 2.7　内存

◆ 8根地址线只能访问256个内存单元

◆ 如果地址线的数量是N，那么，可以通过它访问的内存单元的数量是2的N次方，即2N。


第一十九章 2.8　自动计算

◆ 为了跟踪每条需要执行的指令，运算器内部有一个指令指针寄存器，这个寄存器保存着指令的地址。

◆ 如果这个数已经在指令中给出了，不需要再次访问内存，那这个数就是立即数，比如第一条指令中的207；相反，如果指令中给出的是地址，真正的数还需要用这个地址访问内存才能得到，那它就不能称为立即数，比如这条指令中的12，它只是一个地址，并不是最终要操作的数字，最终要操作的数字还需要用这个地址再次访问内存才能得到。


第二十章 2.9　处理器

◆ 处理器的工作是自动取指令并执行指令。对于任何一款处理器来说，它可以识别哪些指令，是在设计和制造的时候就已经决定了的。任何一款处理器，它可以识别的所有指令的集合，叫作这款处理器的指令集。

◆ 对于任何一款处理器来说，它所包含的指令都可以分为以下几种：算术运算指令、逻辑运算指令、数据传送指令和处理器状态控制指令。


第二十六章 3.3　古老的INTEL 8086处理器

◆ 数据段可以起始于内存中的任何位置

◆ 为了让你写的程序在卖给别人之后，可以在内存中的任何地方正确执行，就只能在编写程序的时候使用相对地址或者逻辑地址，而不能使用真实的物理地址。当加载程序时，这些相对地址还要根据程序实际被加载的位置重新计算。

◆ 为了在硬件一级提供对“段地址:偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器(Code Segment, CS)和数据段寄存器(Data Segment, DS)。

◆ CS是代码段寄存器，DS是数据段寄存器，ES是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS指向一个，ES指向另一个。可以在指令中指定使用DS和ES中的哪一个，如果没有指定，则默认使用DS。SS是栈段(Stack Segment)寄存器

◆ IP是指令指针(Instruction Pointer)寄存器，它只和CS一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS保存代码段的段地址，IP则指向段内偏移。这样，由CS和IP共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改变IP的值，使它指向下一条指令。

◆ 段只能起始于那些能够被16整除的物理内存地址。对8086处理器来说，将这样的内存地址除以16或者右移4位，得到的结果就是逻辑段地址，简称段地址。要访问一个段，需要将段地址传送到段寄存器。

◆ 每个段正好16字节，偏移地址从0000H到000FH。

◆ 同样在不允许段之间重叠的情况下，每个段的最大长度是64KB，因为偏移地址也是16位的，从0000H到FFFFH。在这种情况下，1MB的内存，最多只能划分成16个段，每段长64KB，段地址分别是0000H、1000H、2000H、3000H，…，F000H。

◆ 段地址的选择取决于内存中哪些区域是空闲的。举个例子来说，假如从物理地址00000H开始，一直到82251H处都被其他程序占用着，而后面一直到FFFFFH的地址空间都是自由的，那么，你可以从物理内存地址82251H之后的地方加载你的程序。

◆ 8086处理器的逻辑分段，起始地址都是16的倍数，这称为是按16字节对齐的。

◆ 段的划分是自由的，它可以起始于任何16字节对齐的内存地址，也可以是任意长度，只要不超过64KB。


第三十五章 5.1　计算机的启动过程

◆ 在处理器众多的引脚中，有一个是RESET，用于接受复位信号。每当处理器加电，或者RESET引脚的电平由低变高时[插图]，处理器都会执行硬件初始化，以及一个可选的内部自测试(Build-in Self-Test,BIST)，然后将内部所有寄存器的内容初始化到预置的状态。

◆ 处理器取指令执行的自然顺序是从内存的低地址往高地址推进。如果从0xFFFF0开始执行，这个位置离1MB内存的顶端（物理地址0xFFFFF）只有16字节的长度，一旦IP寄存器的值超过0x000F，比如IP=0x0011，那么，它与CS一起形成的物理地址将因为溢出而变成0x00001，这将回绕到1MB内存的最底端。

◆ 设备当然是很多的，所以这块ROM芯片只针对那些最基本的、对于使用计算机而言最重要的设备，而它所提供的软件例程，也只包含最基本、最常规的功能。正因为如此，这块芯片又叫基本输入输出系统(Base Input ＆ Output System, BIOS)ROM，简称ROM-BIOS。

◆ 在硬盘上，数据的访问是以柱面来组织的。

◆ ROM-BIOS将读取硬盘主引导扇区的内容，将它加载到内存地址0x0000:0x7c00（也就是物理地址0x07C00），然后用一个jmp指令跳到那里接着执行


第三十六章 5.2　创建和使用虚拟机

◆ LBA模式由硬盘控制器在硬件一级上提供支持，所以效率很高，兼容性很好。LBA模式不考虑扇区的物理位置（磁头号、磁道号），而是把它们全部组织起来统一编号。在这种编址方式下，原先的物理扇区被组织成逻辑扇区，且都有唯一的逻辑扇区号。

◆ 扇区在编号时，是以柱面为单位的。即，先是0面0道，接着是1面0道，直到把所有盘面上的0磁道处理完，再接着处理下一个柱面。之所以这样做，是因为我们讲过，要加速硬盘的访问速度，最好不移动磁头。

◆ [插图]这里，LBA是逻辑扇区号，C、H、S是想求得逻辑扇区号的那个物理扇区所在的磁道、磁头和扇区号。


第三十九章 6.2　欢迎来到主引导扇区

◆ 一个有效的主引导扇区，其最后2字节应当是0x55和0xAA。ROM-BIOS程序首先检测这两个标志，如果主引导扇区有效，则以一个段间转移指令jmp 0x0000:0x7c00跳到那里继续执行。


第四十一章 6.4　在屏幕上显示文字

◆ 传统上，这种专门用于显示字符的工作方式称为文本模式。文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。在不同的工作模式下，显卡对显存内容的解释是不同的。

◆ 8086可以访问1MB内存。其中，0x00000～9FFFF属于常规内存，由内存条提供；0xF0000～0xFFFFF由主板上的一个芯片提供，即ROM-BIOS。这样一来，中间还有一个320KB的空洞，即0xA0000～0xEFFFF。传统上，这段地址空间由特定的外围设备来提供，其中就包括显卡。

◆ 一直以来，0xB8000～0xBFFFF这段物理地址空间，是留给显卡的，由显卡来提供，用来显示文本。

◆ 为了访问显存，也需要使用逻辑地址，也就是采用“段地址:偏移地址”的形式，这是处理器的要求。考虑到文本模式下显存的起始物理地址是0xB8000，这块内存可以看成段地址为0xB800，偏移地址从0x0000延伸到0xFFFF的区域，因此我们可以把段地址定为0xB800。

◆ INTEL处理器不允许将一个立即数传送到段寄存器，它只允许这样的指令：[插图]

◆ 数字5和字符5是不同的，显卡在任何时候都认为你发送的是ASCII码。所以，你不应该发送0x05，而应该发送0x35。

◆ 屏幕上的每个字符对应着显存中连续2字节，前一个是字符的ASCII代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）。

◆ 字符的显示属性（1字节）分为两部分，低4位定义的是前景色，高4位定义的是背景色。色彩主要由R、G、B这3位决定，毕竟我们知道，可以由红(R)、绿(G)、蓝(B)三原色来配出其他所有颜色。K是闪烁位，为0时不闪烁，为1时闪烁；I是亮度位，为0时正常亮度，为1时呈高亮。表6-2给出了背景色和前景色的所有可能值。

◆ 一般情况下，如果没有附加任何指示，段地址默认在段寄存器DS中。

◆ 段超越前缀“es:”。这就是说，我们明确要求处理器在生成物理地址时，使用段寄存器ES，而不是默认情况下的段寄存器DS。

◆ 一旦目的操作数被指明是“byte”的，那么，源操作数的宽度也就明确了。相反地，下面的指令就不需要任何修饰：[插图]

◆ 目的操作数的作用应该相当于一个“容器”，故必须是通用寄存器或者内存单元；源操作数呢，也可以是和目的操作数具有相同数据宽度的通用寄存器和内存单元，还可以是立即数。

◆ mov指令的目的操作数不允许为立即数，而且，目的操作数和源操作数不允许同时为内存单元。

◆ 不单是mov指令，其他指令都不支持在两个内存单元之间直接进行操作，包括加、减、乘、除和逻辑运算等指令。事情是明摆着的，既然增加了处理器的复杂性和用两条指令没什么区别，干脆就用两条指令好了。


第四十二章 6.5　显示标号的汇编地址

◆ 处理器访问内存时，采用的是“段地址:偏移地址”的模式。对于任何一个内存段来说，段地址可以开始于任何16字节对齐的地方，偏移地址则总是从0x0000开始递增的。

◆ 汇编地址是在源程序编译期间，编译器为每条指令确定的汇编位置(Assembly Position)，指示该指令相对于程序或者段起始处的距离，以字节计。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。

◆ 在编译阶段，每条指令都被计算并赋予了一个汇编地址，就像它们已经被加载到内存中的某个段里一样。

◆ 源程序的编译是从上往下的，而内存地址的增长是从下往上的（从低地址往高地址方向增长）。

◆ 标号代表并指示它所在位置处的汇编地址

◆ DW(Declare Word)用于声明字数据，DD(Declare Double Word)用于声明双字（两个字）数据，DQ(Declare Quad Word)用于声明四字数据。DB、DW、DD和DQ并不是处理器指令，它只是编译器提供的汇编指令，所以称作伪指令(Pseudo Instruction)

◆ 2024/01/16发表想法

第一种除法

原文：第一种类型是用16位的二进制数除以8位的二进制数。在这种情况下，被除数必须在寄存器AX中，必须事先传送到寄存器AX里。除数可以由8位的通用寄存器或者内存单元提供。指令执行后，商在寄存器AL中，余数在寄存器AH中。

◆ 第一种类型是用16位的二进制数除以8位的二进制数。在这种情况下，被除数必须在寄存器AX中，必须事先传送到寄存器AX里。除数可以由8位的通用寄存器或者内存单元提供。指令执行后，商在寄存器AL中，余数在寄存器AH中。

◆ 任何时候，只要是在指令中涉及内存地址的，都允许使用段超越前缀

◆ 2024/01/16发表想法

第二种除法

原文：第二种类型是用32位的二进制数除以16位的二进制数。在这种情况下，因为16位的处理器无法直接提供32位的被除数，故要求被除数的高16位在寄存器DX中，低16位在寄存器AX中。

◆ 指令中的目的操作数是在编译阶段确定的

◆ xor，在数字逻辑里是异或(eXclusive OR)的意思，或者叫互斥或、互斥的或运算。

◆ xor指令的目的操作数可以是通用寄存器和内存单元，源操作数可以是通用寄存器、内存单元和立即数（不允许两个操作数同时为内存单元）。而且，异或操作是在两个操作数相对应的比特之间单独进行的。一般地，xor指令的两个操作数应当具有相同的数据宽度。

◆ 两条指令的源操作数都采用了二进制数的写法，NASM编译器允许使用下划线来分开它们，好处是可以更清楚地观察到那些我们感兴趣的比特。

◆ add指令需要两个操作数，目的操作数可以是8位或者16位的通用寄存器，或者指向8位或者16位实际操作数的内存地址；源操作数可以是相同数据宽度的8位或者16位通用寄存器、指向8位或者16位实际操作数的内存地址，或者立即数，但不允许两个操作数同时为内存单元。相加后，结果保存在目的操作数中。


第四十三章 6.6　使程序进入无限循环状态

◆ 编译器是如何区分这两种不同的转移方式呢？很简单，当它看到jmp之后是一个绝对地址，如0xF000:0x2000时，它就知道应当编译成使用操作码0xEA的直接绝对转移指令。相反地，如果它发现jmp之后是一个标号，那么，它就会编译成使用操作码为0xE9的相对转移指令。关键字“near”不是最主要的，它仅仅用于指示相对量是16位的。


第四十四章 6.7　完成并编译主引导扇区代码

◆ 一个有效的主引导扇区，其最后2字节的数据必须是0x55和0xAA。

◆ 在INTEL处理器上，将一个字写入内存时，是采用低端字节序的，低字节0x55置入低地址端（在前），高字节0xAA置入高地址端（在后）。

◆ 伪指令times可用于重复它后面的指令若干次。


第五十章 7.2　跳过非指令的数据区

◆ jmp near start这种指令，机器指令的操作码是0xE9，操作数是一个16位的相对偏移量，这叫作相对近转移

