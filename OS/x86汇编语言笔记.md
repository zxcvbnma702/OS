《x86汇编语言：从实模式到保护模式（第2版）》

李忠 王晓波 余洁
207个笔记

第一十四章 2.3　具有记忆功能的器件——寄存器

◆ 如果需要，寄存器可以随时锁存新的数字，以前锁存的数字会被新的数字冲掉。从这个意义上来说，任何数字都是临时被保存在这里的，不会长久，属于临时性寄存。这就是“寄存器”一词的由来。


第一十八章 2.7　内存

◆ 8根地址线只能访问256个内存单元

◆ 如果地址线的数量是N，那么，可以通过它访问的内存单元的数量是2的N次方，即2N。


第一十九章 2.8　自动计算

◆ 为了跟踪每条需要执行的指令，运算器内部有一个指令指针寄存器，这个寄存器保存着指令的地址。

◆ 如果这个数已经在指令中给出了，不需要再次访问内存，那这个数就是立即数，比如第一条指令中的207；相反，如果指令中给出的是地址，真正的数还需要用这个地址访问内存才能得到，那它就不能称为立即数，比如这条指令中的12，它只是一个地址，并不是最终要操作的数字，最终要操作的数字还需要用这个地址再次访问内存才能得到。


第二十章 2.9　处理器

◆ 处理器的工作是自动取指令并执行指令。对于任何一款处理器来说，它可以识别哪些指令，是在设计和制造的时候就已经决定了的。任何一款处理器，它可以识别的所有指令的集合，叫作这款处理器的指令集。

◆ 对于任何一款处理器来说，它所包含的指令都可以分为以下几种：算术运算指令、逻辑运算指令、数据传送指令和处理器状态控制指令。


第二十六章 3.3　古老的INTEL 8086处理器

◆ 数据段可以起始于内存中的任何位置

◆ 为了让你写的程序在卖给别人之后，可以在内存中的任何地方正确执行，就只能在编写程序的时候使用相对地址或者逻辑地址，而不能使用真实的物理地址。当加载程序时，这些相对地址还要根据程序实际被加载的位置重新计算。

◆ 为了在硬件一级提供对“段地址:偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器(Code Segment, CS)和数据段寄存器(Data Segment, DS)。

◆ CS是代码段寄存器，DS是数据段寄存器，ES是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS指向一个，ES指向另一个。可以在指令中指定使用DS和ES中的哪一个，如果没有指定，则默认使用DS。SS是栈段(Stack Segment)寄存器

◆ IP是指令指针(Instruction Pointer)寄存器，它只和CS一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS保存代码段的段地址，IP则指向段内偏移。这样，由CS和IP共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改变IP的值，使它指向下一条指令。

◆ 段只能起始于那些能够被16整除的物理内存地址。对8086处理器来说，将这样的内存地址除以16或者右移4位，得到的结果就是逻辑段地址，简称段地址。要访问一个段，需要将段地址传送到段寄存器。

◆ 每个段正好16字节，偏移地址从0000H到000FH。

◆ 同样在不允许段之间重叠的情况下，每个段的最大长度是64KB，因为偏移地址也是16位的，从0000H到FFFFH。在这种情况下，1MB的内存，最多只能划分成16个段，每段长64KB，段地址分别是0000H、1000H、2000H、3000H，…，F000H。

◆ 段地址的选择取决于内存中哪些区域是空闲的。举个例子来说，假如从物理地址00000H开始，一直到82251H处都被其他程序占用着，而后面一直到FFFFFH的地址空间都是自由的，那么，你可以从物理内存地址82251H之后的地方加载你的程序。

◆ 8086处理器的逻辑分段，起始地址都是16的倍数，这称为是按16字节对齐的。

◆ 段的划分是自由的，它可以起始于任何16字节对齐的内存地址，也可以是任意长度，只要不超过64KB。


第三十五章 5.1　计算机的启动过程

◆ 在处理器众多的引脚中，有一个是RESET，用于接受复位信号。每当处理器加电，或者RESET引脚的电平由低变高时[插图]，处理器都会执行硬件初始化，以及一个可选的内部自测试(Build-in Self-Test,BIST)，然后将内部所有寄存器的内容初始化到预置的状态。

◆ 处理器取指令执行的自然顺序是从内存的低地址往高地址推进。如果从0xFFFF0开始执行，这个位置离1MB内存的顶端（物理地址0xFFFFF）只有16字节的长度，一旦IP寄存器的值超过0x000F，比如IP=0x0011，那么，它与CS一起形成的物理地址将因为溢出而变成0x00001，这将回绕到1MB内存的最底端。

◆ 设备当然是很多的，所以这块ROM芯片只针对那些最基本的、对于使用计算机而言最重要的设备，而它所提供的软件例程，也只包含最基本、最常规的功能。正因为如此，这块芯片又叫基本输入输出系统(Base Input ＆ Output System, BIOS)ROM，简称ROM-BIOS。

◆ 在硬盘上，数据的访问是以柱面来组织的。

◆ ROM-BIOS将读取硬盘主引导扇区的内容，将它加载到内存地址0x0000:0x7c00（也就是物理地址0x07C00），然后用一个jmp指令跳到那里接着执行


第三十六章 5.2　创建和使用虚拟机

◆ LBA模式由硬盘控制器在硬件一级上提供支持，所以效率很高，兼容性很好。LBA模式不考虑扇区的物理位置（磁头号、磁道号），而是把它们全部组织起来统一编号。在这种编址方式下，原先的物理扇区被组织成逻辑扇区，且都有唯一的逻辑扇区号。

◆ 扇区在编号时，是以柱面为单位的。即，先是0面0道，接着是1面0道，直到把所有盘面上的0磁道处理完，再接着处理下一个柱面。之所以这样做，是因为我们讲过，要加速硬盘的访问速度，最好不移动磁头。

◆ [插图]这里，LBA是逻辑扇区号，C、H、S是想求得逻辑扇区号的那个物理扇区所在的磁道、磁头和扇区号。


第三十九章 6.2　欢迎来到主引导扇区

◆ 一个有效的主引导扇区，其最后2字节应当是0x55和0xAA。ROM-BIOS程序首先检测这两个标志，如果主引导扇区有效，则以一个段间转移指令jmp 0x0000:0x7c00跳到那里继续执行。


第四十一章 6.4　在屏幕上显示文字

◆ 传统上，这种专门用于显示字符的工作方式称为文本模式。文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。在不同的工作模式下，显卡对显存内容的解释是不同的。

◆ 8086可以访问1MB内存。其中，0x00000～9FFFF属于常规内存，由内存条提供；0xF0000～0xFFFFF由主板上的一个芯片提供，即ROM-BIOS。这样一来，中间还有一个320KB的空洞，即0xA0000～0xEFFFF。传统上，这段地址空间由特定的外围设备来提供，其中就包括显卡。

◆ 一直以来，0xB8000～0xBFFFF这段物理地址空间，是留给显卡的，由显卡来提供，用来显示文本。

◆ 为了访问显存，也需要使用逻辑地址，也就是采用“段地址:偏移地址”的形式，这是处理器的要求。考虑到文本模式下显存的起始物理地址是0xB8000，这块内存可以看成段地址为0xB800，偏移地址从0x0000延伸到0xFFFF的区域，因此我们可以把段地址定为0xB800。

◆ INTEL处理器不允许将一个立即数传送到段寄存器，它只允许这样的指令：[插图]

◆ 数字5和字符5是不同的，显卡在任何时候都认为你发送的是ASCII码。所以，你不应该发送0x05，而应该发送0x35。

◆ 屏幕上的每个字符对应着显存中连续2字节，前一个是字符的ASCII代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）。

◆ 字符的显示属性（1字节）分为两部分，低4位定义的是前景色，高4位定义的是背景色。色彩主要由R、G、B这3位决定，毕竟我们知道，可以由红(R)、绿(G)、蓝(B)三原色来配出其他所有颜色。K是闪烁位，为0时不闪烁，为1时闪烁；I是亮度位，为0时正常亮度，为1时呈高亮。表6-2给出了背景色和前景色的所有可能值。

◆ 一般情况下，如果没有附加任何指示，段地址默认在段寄存器DS中。

◆ 段超越前缀“es:”。这就是说，我们明确要求处理器在生成物理地址时，使用段寄存器ES，而不是默认情况下的段寄存器DS。

◆ 一旦目的操作数被指明是“byte”的，那么，源操作数的宽度也就明确了。相反地，下面的指令就不需要任何修饰：[插图]

◆ 目的操作数的作用应该相当于一个“容器”，故必须是通用寄存器或者内存单元；源操作数呢，也可以是和目的操作数具有相同数据宽度的通用寄存器和内存单元，还可以是立即数。

◆ mov指令的目的操作数不允许为立即数，而且，目的操作数和源操作数不允许同时为内存单元。

◆ 不单是mov指令，其他指令都不支持在两个内存单元之间直接进行操作，包括加、减、乘、除和逻辑运算等指令。事情是明摆着的，既然增加了处理器的复杂性和用两条指令没什么区别，干脆就用两条指令好了。


第四十二章 6.5　显示标号的汇编地址

◆ 处理器访问内存时，采用的是“段地址:偏移地址”的模式。对于任何一个内存段来说，段地址可以开始于任何16字节对齐的地方，偏移地址则总是从0x0000开始递增的。

◆ 汇编地址是在源程序编译期间，编译器为每条指令确定的汇编位置(Assembly Position)，指示该指令相对于程序或者段起始处的距离，以字节计。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。

◆ 在编译阶段，每条指令都被计算并赋予了一个汇编地址，就像它们已经被加载到内存中的某个段里一样。

◆ 源程序的编译是从上往下的，而内存地址的增长是从下往上的（从低地址往高地址方向增长）。

◆ 标号代表并指示它所在位置处的汇编地址

◆ DW(Declare Word)用于声明字数据，DD(Declare Double Word)用于声明双字（两个字）数据，DQ(Declare Quad Word)用于声明四字数据。DB、DW、DD和DQ并不是处理器指令，它只是编译器提供的汇编指令，所以称作伪指令(Pseudo Instruction)

◆ 2024/01/16发表想法

第一种除法

原文：第一种类型是用16位的二进制数除以8位的二进制数。在这种情况下，被除数必须在寄存器AX中，必须事先传送到寄存器AX里。除数可以由8位的通用寄存器或者内存单元提供。指令执行后，商在寄存器AL中，余数在寄存器AH中。

◆ 第一种类型是用16位的二进制数除以8位的二进制数。在这种情况下，被除数必须在寄存器AX中，必须事先传送到寄存器AX里。除数可以由8位的通用寄存器或者内存单元提供。指令执行后，商在寄存器AL中，余数在寄存器AH中。

◆ 任何时候，只要是在指令中涉及内存地址的，都允许使用段超越前缀

◆ 2024/01/16发表想法

第二种除法

原文：第二种类型是用32位的二进制数除以16位的二进制数。在这种情况下，因为16位的处理器无法直接提供32位的被除数，故要求被除数的高16位在寄存器DX中，低16位在寄存器AX中。

◆ 指令中的目的操作数是在编译阶段确定的

◆ xor，在数字逻辑里是异或(eXclusive OR)的意思，或者叫互斥或、互斥的或运算。

◆ xor指令的目的操作数可以是通用寄存器和内存单元，源操作数可以是通用寄存器、内存单元和立即数（不允许两个操作数同时为内存单元）。而且，异或操作是在两个操作数相对应的比特之间单独进行的。一般地，xor指令的两个操作数应当具有相同的数据宽度。

◆ 两条指令的源操作数都采用了二进制数的写法，NASM编译器允许使用下划线来分开它们，好处是可以更清楚地观察到那些我们感兴趣的比特。

◆ add指令需要两个操作数，目的操作数可以是8位或者16位的通用寄存器，或者指向8位或者16位实际操作数的内存地址；源操作数可以是相同数据宽度的8位或者16位通用寄存器、指向8位或者16位实际操作数的内存地址，或者立即数，但不允许两个操作数同时为内存单元。相加后，结果保存在目的操作数中。


第四十三章 6.6　使程序进入无限循环状态

◆ 编译器是如何区分这两种不同的转移方式呢？很简单，当它看到jmp之后是一个绝对地址，如0xF000:0x2000时，它就知道应当编译成使用操作码0xEA的直接绝对转移指令。相反地，如果它发现jmp之后是一个标号，那么，它就会编译成使用操作码为0xE9的相对转移指令。关键字“near”不是最主要的，它仅仅用于指示相对量是16位的。


第四十四章 6.7　完成并编译主引导扇区代码

◆ 一个有效的主引导扇区，其最后2字节的数据必须是0x55和0xAA。

◆ 在INTEL处理器上，将一个字写入内存时，是采用低端字节序的，低字节0x55置入低地址端（在前），高字节0xAA置入高地址端（在后）。

◆ 伪指令times可用于重复它后面的指令若干次。


第五十章 7.2　跳过非指令的数据区

◆ jmp near start这种指令，机器指令的操作码是0xE9，操作数是一个16位的相对偏移量，这叫作相对近转移


第五十一章 7.3　在数据声明中使用字面值

◆ 在NASM里，“\”是续行符，当一行写不下时，可以在行尾使用这个符号，以表明下一行与当前行应该合并为一行。和上一章相同，在用伪指令db声明字符的ASCII码数据时也可以使用字面值。在编译阶段，编译器将把“L”“a”等转换成与它们等价的ASCII代码。除了ASCII码，这里还声明了每个字符的显示属性值0x07，都是已经讲过的知识，相信很好理解。


第五十二章 7.4　段地址的初始化

◆ 我们可以把这512字节的区域看成一个单独的段，段的基地址是0x07C0，段长512字节。


第五十三章 7.5　段之间的批量数据传送

◆ movsb或者movsw指令。这两个指令通常用于把数据从内存中的一个地方批量地传送（复制）到另一个地方，处理器把它们看成数据串。但是，movsb的传送是以字节为单位的，而movsw的传送是以字为单位的。

◆ movsb和movsw指令执行时，原始数据串的段地址由DS指定，偏移地址由SI指定，简写为DS:SI；要传送到的目的地址由ES:DI指定；传送的字节数(movsb)或者字数(movsw)由CX指定。

◆ 正向传送是指传送操作的方向是从内存区域的低地址端到高地址端；反向传送则正好相反。正向传送时，每传送一字节(movsb)或者一个字(movsw)，SI和DI加1或者加2；反向传送时，每传送一字节(movsb)或者一个字(movsw)时，SI和DI减去1或者减去2。不管是正向传送还是反向传送，也不管每次传送的是字节还是字，每传送一次，CX的内容自动减1，因为CX用来指定传送的次数。

◆ 在8086处理器里，有一个特殊的寄存器，叫作FLAGS，翻译过来叫标志寄存器，用来存放各种标志信息。

◆ 位10是方向标志DF(Direction Flag)，通过将这一位清0或者置1，就能控制movsb和movsw的传送方向。

◆ 源程序第19行是方向标志清0指令cld。这是个无操作数指令，与其相反的是置方向标志指令std。cld指令将DF标志清0，以指示传送是正方向的。和cld功能相反的是std指令，它将DF标志置位(1)。此时，传送的方向是从高地址到低地址。

◆ movsw指令，操作码是0xA5，该指令没有操作数。使用movsw而不是movsb的原因是按字操作比按字节操作要快。

◆ 单纯的movsb和movsw只能执行一次，如果希望处理器自动地反复执行，需要加上指令前缀rep(repeat)，意思是CX不为零则重复。rep movsw的操作码是0xF3 0xA5，它将重复执行movsw直到CX的内容为零。


第五十四章 7.6　使用循环分解数位

◆ 循环依靠的是循环指令loop

◆ loop digit指令也是颇具迷惑性的指令，它的机器指令操作码是0xE2，后面跟着一字节的操作数，而且也是相对于标号处的偏移量，是在编译阶段，编译器用标号digit所在位置的汇编地址减去loop指令的下一条指令的汇编地址得到的。

◆ mov［bx］，dl做相同的事情，那就是把寄存器DL中的内容，传送到以寄存器DS的内容为段地址，以寄存器BX的内容为偏移地址的内存单元中去

◆ 指令中的中括号是必需的，否则就是传送到寄存器BX中，而不是寄存器BX的内容所指示的内存单元了。

◆ 在8086处理器上，如果要用寄存器来提供偏移地址，只能使用寄存器BX、SI、DI、BP，不能使用其他寄存器。

◆ 寄存器BX最初的功能之一就是用来提供数据访问的基地址，所以又叫基址寄存器(Base Address Register)。之所以不能用寄存器SP、IP、AX、CX、DX，这是一种硬性规定，说不上有什么特别的理由。

◆ 可以在任何带有内存操作数的指令中使用寄存器BX、SI或者DI提供偏移地址。

◆ inc是加1指令，操作数可以是8位或者16位的寄存器，也可以是字节或者字内存单元。

◆ 和inc指令相对的是dec指令，用于将目标操作数的内容减1

◆ 在指令的地址部分使用寄存器，而不是数值或者标号（其实标号是数值的等价形式，在编译后也是数值）有一个明显的好处，那就是可以在循环体里方便地改变偏移地址，如果使用数值就做不到这一点。


第五十五章 7.7　计算机中的负数

◆ 十进制数-1在寄存器AL中的二进制形式是[插图]即0xFF；十进制数-2在寄存器AL中的二进制形式是[插图]即0xFE。如果是16位的寄存器，则相应地，要保留相减结果的最右边16位。因此，十进制数-1在寄存器AX中的二进制形式是[插图]即0xFFFF；十进制数-2在寄存器AX中的二进制形式是[插图]即0xFFFE。

◆ 有符号数是分正负的，而且规定，数的正负要通过它的最高位来辨别。如果最高位是0，它就是正数；如果是1，就是负数。如此一来，在8位的字节运算环境中，正数的范围是00000000～01111111，即十进制的0～127；负数的范围是10000000～11111111，即十进制的-128～-1。

◆ 因为“负数的负数”是正数，所以只需要用0减去这个负数就行。

◆ 在8086处理器中，有一条指令专门做这件事，它就是neg。neg指令带有一个操作数，可以是8位或者16位的寄存器，或者内存单元。如[插图]它的功能很简单，用0减去指令中指定的操作数

◆ cbw没有操作数，操作码为98。它的功能是，将寄存器AL中的有符号数扩展到整个寄存器AX。举个例子，如果寄存器AL中的内容为01001111，那么执行该指令后，寄存器AX中的内容为0000000001001111；如果寄存器AL中的内容为10001101，执行该指令后，寄存器AX中的内容为1111111110001101。

◆ cwd也没有操作数，操作码为99。它的功能是，将寄存器AX中的有符号数扩展到DX:AX。举个例子，如果寄存器AX中的内容为0100111101111001，那么执行该指令后，寄存器DX中的内容为0000000000000000，寄存器AX中的内容不变；如果寄存器AX中的内容为1000110110001011，那么执行该指令后，寄存器DX中的内容为1111111111111111，寄存器AX中的内容同样不变。

◆ 很多处理器内部不构造减法电路，而是使用加法电路来做减法。

◆ 减法指令sub，该指令和加法指令add相似，目的操作数可以是8位或者16位通用寄存器，也可以是8位或者16位的内存单元；源操作数可以是通用寄存器，也可以是内存单元或者立即数（不允许两个操作数同时为内存单元）。

◆ 指令div。严格地说，它应该叫作无符号除法指令(Unsigned Divide)，因为这条指令只能工作于无符号数。

◆ 处理器专门提供了一个有符号数除法指令idiv(Signed Divide)。idiv的指令格式和div相同，除了它是专门用于计算有符号数的。

◆ 如果是无符号数计算，必须使用div指令；如果你是在做有符号数计算，就应当使用idiv指令。


第五十六章 7.8　数位的显示

◆ 寄存器SI的作用相当于索引，因此它被称为索引寄存器(Index Register)，或者叫变址寄存器。另一个常用的变址寄存器是DI。

◆ 数据的传送是按低端字节序的，寄存器的低字节传送到显示缓冲区的低地址部分（字节），寄存器的高字节传送到显示缓冲区的高地址部分（字节）。

◆ 指令jns show的意思是，如果未设置符号位，则转移到标号“show”所在的位置处执行。

◆ INTEL处理器的标志寄存器里有符号位SF(Sign Flag)，很多算术逻辑运算都会影响到该位，比如这里的dec指令。如果计算结果的最高位是比特“0”，处理器把SF位置“0”，否则SF位置“1”。


第五十七章 7.9　其他标志位和条件转移指令

◆ 奇偶标志位PF当运算结果出来后，如果最低8位中，有偶数个为1的比特，则PF=1；否则PF=0。

◆ 当处理器进行算术操作时，如果最高位有向前进位或借位的情况发生，则CF=1；否则CF=0。

◆ 溢出标志OF，该标志的意思是，假定你进行的是有符号数运算，如果运算结果是正确的，那么OF=0，否则OF=1。

◆ 简单地说，OF标志用于指示两个有符号数的运算结果是否错误。

◆ [插图]

◆ 条件转移指令的操作数是标号。编译成机器码后，操作数是一个立即数，是相对于目标指令的偏移量。在16位处理器上，偏移量可以是8位（短转移）或者16位（相对近转移）。

◆ jz的意思是结果为零（ZF标志为1）则转移；jnz的意思是结果不为零（ZF标志为0）则转移。

◆ jo的意思是结果溢出（OF标志为1）则转移，jno的意思是结果未溢出（OF标志为0）则转移。

◆ jc的意思是有进位（CF标志为1）则转移，jnc的意思是没有进位（CF标志为0）则转移。

◆ jp的意思是如果PF标志为1则转移，jnp的意思是如果PF标志不为1（为0）则转移。

◆ 比较指令cmp，它需要两个操作数，目的操作数可以是8位或者16位通用寄存器，也可以是8位或者16位内存单元；源操作数可以是与目的操作数宽度一致的通用寄存器、内存单元或者立即数，但两个操作数同时为内存单元的情况除外。

◆ cmp指令在功能上和sub指令相同，唯一不同之处在于，cmp指令仅仅根据计算的结果设置相应的标志位，而不保留计算结果，因此也就不会改变两个操作数的原有内容。cmp指令将会影响到CF、OF、SF、ZF、AF和PF标志位。

◆ 条件转移指令是jcxz(jump if CX is zero)，意思是当寄存器CX的内容为零时则转移。执行这条指令时，处理器先测试寄存器CX是否为零。


第五十八章 7.10　NASM编译器的$和$$标记

◆ NASM编译器提供了一个标记“$”，该标记等同于标号，你可以把它看成一个隐藏在当前行行首的标号。因此，jmp near $的意思是，转移到当前指令继续执行，它和[插图]是一样的，没有区别，但不需要使用标号，更不必为给标号起一个有意义的名字而伤脑筋。

◆ $是当前位置的汇编地址

◆ $$是NASM编译器提供的另一个标记，代表当前汇编节（段）的起始汇编地址。当前程序没有定义节或段，就默认地自成一个汇编段，而且起始的汇编地址是0（程序起始处）。这样，用当前汇编地址减去程序开头的汇编地址(0)，就是程序实体的大小。


第六十六章 8.5　累加和各个数位的分解与显示

◆ 栈也被定义成一个内存段，叫栈段(Stack Segment)，由段寄存器SS指向。

◆ 栈指针寄存器SP(Stack Pointer)来指示下一个数据应当压入栈内的什么位置，或者数据从哪里出栈。

◆ 定义栈需要两个连续的步骤，即初始化段寄存器SS和栈指针SP的内容。

◆ ，or执行的是逻辑“或”。数字逻辑中的“或”用于表示两个命题并列的情况。如果0代表假，1代表真

◆ or指令的目的操作数可以是8位或者16位的通用寄存器，或者包含8/16位实际操作数的内存单元，源操作数可以是与目的操作数数据宽度相同的通用寄存器、内存单元或者立即数。

◆ or指令不允许目的操作数和源操作数都是内存单元的情况出现。当or指令执行时，两个操作数相对应的比特之间分别进行各自的逻辑“或”运算，结果位于目的操作数中。

◆ or指令对标志寄存器的影响是：OF和CF位被清零，SF、ZF、PF位的状态依计算结果而定，AF位的状态未定义。

◆ 在16位处理器上，and指令的两个操作数都应当是字节或者字。其中，目的操作数可以是通用寄存器和内存单元；源操作数可以是通用寄存器、内存单元或者立即数，但不允许两个操作数同时为内存单元，而且它们在数据宽度上应当一致。

◆ and指令执行后，OF和CF位被清零，SF、ZF、PF位的状态依计算结果而定，AF位的状态未定义。

◆ push指令只接受16位的操作数，为什么要对内存操作数使用关键字“word”。事实上，8086处理器只能压入一个字；但其后的32位和64位处理器允许压入字、双字或者四字，因此，关键字是必不可少的。

◆ 代码段在处理器上执行时，是由低地址端向高地址端推进的，而压栈操作则正好相反，是从高地址端向低地址端推进的。

◆ push指令不影响任何标志位。

◆ 2024/01/30发表想法

数值入栈，寄存器中的值不变

原文：push指令的操作数可以是16位寄存器或者16位内存单元，push指令执行后，压入栈中的仅仅是该寄存器或者内存单元里的数值，与该寄存器或内存单元不再相干。

◆ 栈在本质上也只是普通的内存区域，之所以要用push和pop指令来访问，是因为你把它看成栈而已。实际上，如果你把它看成普通的数据段而忘掉它是一个栈，那么它将不再神秘。

◆ 要注意保持栈平衡。如果在做某件事的时候要使用栈，那么，栈指针寄存器SP在做这件事之前的值，应当和这件事做完后的值相同。就是说，push指令和pop指令的数量应当是相同的。

◆ 在编写程序前，必须充分估计所需要的栈空间，以防止破坏有用的数据。特别是在栈段和其他段属于同一个段的时候。

◆ 尽管不能完全阻止程序中的错误，但是，通过将栈定义到一个单独的64KB段，可以使错误仅局限于栈，而不破坏其他段的有用数据。假如栈的段地址是0x0000，大小是64KB，那么，无论SP怎样变化，压栈和出栈操作始终会在该段内进行，而不会影响到其他无关的内存区域。


第六十八章 8.7　8086处理器的寻址方式

◆ 寻址方式就是如何找到要操作的数据，以及如何找到存放操作结果的地方。

◆ 8086处理器访问内存时，采用的是段地址左移4位，然后加上偏移地址，来形成20位物理地址的模式，段地址由4个段寄存器之一来提供，偏移地址要由指令来提供。

◆ 所谓的内存寻址方式，就是如何在指令中指定操作数的偏移地址，供处理器访问内存时使用，这个偏移地址也叫有效地址(Effective Address, EA)。换句话说，内存寻址方式就是在指令中指定偏移地址（有效地址）如何计算。

◆ 基址寻址，就是先指定一个基准位置，数据的偏移地址（有效地址）取决于它到基准位置的位移或者说距离(Displacement)。

◆ 要使用基址寻址的话，必须在指令的地址部分使用基址寄存器BX或者BP来提供一个基准地址。

◆ 它采用是基址寄存器BP，在形成20位的物理地址时，默认的段寄存器是SS。也就是说，它经常用于访问栈。这条指令执行时，处理器将栈段寄存器SS的内容左移4位，加上寄存器BP的内容，形成20位的物理地址，并将该地址处的一个字传送到寄存器AX中。

◆ 变址寻址类似于基址寻址，唯一不同之处在于这种寻址方式使用的是变址寄存器（或称索引寄存器）SI和DI。

◆ 和基址寻址一样，当带有这种操作数的指令执行时，除非使用了段超越前缀，处理器会访问由段寄存器DS指向的数据段，偏移地址由寄存器SI或者DI提供。

◆ 使用基址变址的操作数可以使用一个基址寄存器（BX或者BP），外加一个变址寄存器（SI或者DI）。在这种寻址方式下，基址寄存器BX或者BP是固定不变的，是真正作为基地址来使用的；变址寄存器SI或者DI是可变的，用来提供位移。

◆ 基址变址寻址允许在基址寄存器和变址寄存器的基础上再带一个位移，但它必须是一个数值。


第七十二章 9.2　用户程序的结构

◆ INTEL 8086处理器的工作模式是将内存分成逻辑上的段，指令的获取和数据的访问一律按“段地址:偏移地址”的方式进行。

◆ INTEL处理器要求段在内存中的起始物理地址起码是16字节对齐的，或者说必须是16的倍数，能被16整除。编写程序时定义的段迟早要加载到内存中，成为内存中的段，所以在编写源程序时定义的段也必须至少按16字节对齐。

◆ 要在编写程序时指定段的对齐方式，应该使用“align=”子句，并指定一个具体的对齐。比如说，“align=16”就表示段是16字节对齐的，“align=32”就表示段是32字节对齐的。

◆ 段的汇编地址其实就是段内第一个元素（数据、指令）到整个程序起始处的距离。

◆ 为了将一个段对齐于特定的汇编地址，可能需要在它前面的那个段内填充数据。

◆ 2024/02/01发表想法

section.段名称.start

原文：每个段都有一个汇编地址，它是相对于整个程序开头(0)的。为了方便取得该段的汇编地址，NASM编译器提供了以下的表达式，可以用在你的程序中

◆ 段定义语句还可以包含“vstart=”子句。在没有vstart子句的时候，尽管定义了段，但是，引用某个标号时，该标号处的汇编地址依然是从整个程序的开头计算的，而不是从段的开头处计算的，这就很麻烦（有时候也很有用）。因此，vstart可以解决这个问题。

◆ “putch”是段code中的一个标号，原则上，该标号代表的汇编地址应该从程序开头计算，而不是从它所在的段开始计算。但是，因为段code的定义中有“vstart=0”子句，所以，标号“putch”的汇编地址要从它所在段的开头计算，而且从0开始计算。

◆ 2024/02/01发表想法

程序头部必须信息1

原文：①用户程序的尺寸，即以字节为单位的大小。这对加载器来说是很重要的，加载器需要根据这一信息来决定读取多少个逻辑扇区（在本书中，所有程序在硬盘上所占用的逻辑扇区都是连续的）。

◆ 该段并没有vstart子句，所以，标号“program_end”所代表的汇编地址是从整个程序的开头计算的。换句话说，program_end所代表的汇编地址，在数值上等于整个程序的长度。

◆ 2024/02/01发表想法

程序头部必需信息2

原文：②应用程序的入口点，包括段地址和偏移地址。加载器并不清楚用户程序的分段情况，更不知道第一条要执行的指令在用户程序中的位置。因此，必须在头部给出第一条指令的段地址和偏移地址，这就是所谓的应用程序入口点(Entry Point)。

◆ 2024/02/01发表想法

程序头部必需信息3

原文：③段重定位表。用户程序可能包含不止一个段，比较大的程序可能会包含多个代码段和多个数据段。这些段如何使用是用户程序自己的事，但前提是程序加载到内存后，每个段的地址必须重新确定一下。

◆ 段的重定位是加载器的工作，它需要知道每个段在用户程序内的位置，即它们分别位于用户程序内的多少字节处。为此，需要在用户程序头部建立一张段重定位表。


第七十三章 9.3　加载程序（器）的工作流程

◆ 从大的方面来说，加载器要加载一个用户程序，并使之开始执行，需要决定两件事。第一，看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序；第二，用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少。

◆ 常数是用伪指令equ声明的，它的意思是“等于”。本语句的意思是，用标号app_lba_start来代表数值100

◆ 物理地址0x0FFFF以下，是加载器及其栈的势力范围；物理地址A0000以上，是BIOS和外围设备的势力范围，有很多传统的老式设备将自己的存储器和只读存储器映射到这个空间。

◆ 因为该定义中有“vstart=0x7c00”子句，所以，它就不那么多余了。一旦有了该子句，段内所有元素的汇编地址都将从0x7c00开始计算。否则，因为主引导程序的实际加载地址是0x0000:0x7c00，当我们引用一个标号时，还得手工加上那个落差0x7c00。

◆ 使用输入输出控制设备集中器(I/O Controller Hub, ICH)芯片，该芯片的作用是连接不同的总线，并协调各个I/O接口对处理器的访问。在个人计算机上，这块芯片就是所谓的南桥。

◆ 处理器通过局部总线连接到ICH内部的处理接口电路。然后，在ICH内部，又通过总线与各个I/O接口相连。在ICH内部，集成了一些常规的外围设备接口，如USB、PATA(IDE)、SATA、老式总线接口(LPC)、时钟等，这些东西对计算机来说必不可少，故直接集成在ICH内，我们后面还会详细介绍它们的功能。

◆ [插图]

◆ ICH还提供了对PCI或者PCI Express总线的支持，该总线向外延伸，连接着主板上的若干个扩展槽，就是刚才说的插槽。举个实例，如果你想连接显示器，那么就要先插入显卡，然后再把显示器接到显卡上。

◆ 处理器是通过端口(Port)来和外围设备打交道的。本质上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处仅仅在于，这些叫作端口的寄存器位于I/O接口电路中。

◆ PATA/SATA接口就有几个端口，分别是命令端口（当向该端口写入0x20时，表明是从硬盘读数据；写入0x30时，表明是向硬盘写数据）、状态端口（处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误）、参数端口（处理器通过这些端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号）和数据端口（通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据）。

◆ ICH芯片内部通常集成了两个PATA/SATA接口，分别是主硬盘接口和副硬盘接口。这样一来，主硬盘接口分配的端口号是0x1f0～0x1f7，副硬盘接口分配的端口号是0x170～0x177。

◆ 在INTEL的系统中，只允许65536（十进制数）个端口存在，端口号从0到65535(0x0000～0xffff)。因为是独立编址，所以，端口的访问不能使用类似于mov这样的指令，取而代之的是in和out指令。

◆ in指令的目的操作数必须是寄存器AL或者AX，当访问8位的端口时，使用寄存器AL；访问16位的端口时，使用AX。in指令的源操作数应当是寄存器DX，用来指定端口号。

◆ in al，dx的机器指令码是0xEC，in ax，dx的机器指令码是0xED，都是一字节的。之所以如此简短，是因为in指令不允许使用别的通用寄存器，也不允许使用内存地址作为操作数。

◆ in指令不影响任何标志位。

◆ out指令正好和in指令相反，目的操作数可以是8位立即数或者寄存器DX，源操作数必须是寄存器AL或者AX。

◆ out指令不影响任何标志位。

◆ 硬盘读写的基本单位是扇区。就是说，要读就至少读一个扇区，要写就至少写一个扇区，不可能仅读写一个扇区中的几个字节。这样一来，就使得主机和硬盘之间的数据交换是成块的，所以硬盘是典型的块设备。

◆ 从硬盘读写数据，最经典的方式是向硬盘控制器分别发送磁头号、柱面号和扇区号（扇区在某个柱面上的编号），这称为CHS模式。

◆ 最早的逻辑扇区编址方法是LBA28，使用28比特来表示逻辑扇区号，从逻辑扇区0x0000000到0xFFFFFFF，共可以表示228=268435456个扇区。每个扇区有512字节，所以LBA28可以管理128 GB的硬盘。

◆ LBA48，采用48比特来表示逻辑扇区号。如此一来，就可以管理131072 TB的硬盘容量了。

◆ 个人计算机上的主硬盘控制器被分配了8位端口，端口号从0x1f0到0x1f7。

◆ 2024/02/02发表想法

读取硬盘扇区第一步

原文：第1步，设置要读取的扇区数量。这个数值要写入0x1f2端口。这是个8位端口，因此每次只能读写255个扇区

◆ 2024/02/02发表想法

读取硬盘扇区第二步

原文：第2步，设置起始LBA扇区号。扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。28位的扇区号太长，需要将其分成4段，分别写入端口0x1f3、0x1f4、0x1f5和0x1f6。其中，0x1f3号端口存放的是0～7位；0x1f4号端口存放的是8～15位；0x1f5号端口存放的是16～23位，最后4位在0x1f6号端口。

◆ 在现行的体系下，每个PATA/SATA接口允许挂接两块硬盘，分别是主盘(Master)和从盘(Slave)。如图9-11所示，0x1f6端口的低4位用于存放逻辑扇区号的24～27位，第4位用于指示硬盘号，0表示主盘，1表示从盘。高3位是“111”，表示LBA模式。

◆ 2024/02/02发表想法

读取硬盘扇区第三步

原文：第3步，向端口0x1f7写入0x20，请求硬盘读。

◆ 2024/02/02发表想法

读取硬盘扇区第四步

原文：第4步，等待读写操作完成。端口0x1f7既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。如图9-12所示，在它内部操作期间，它将0x1f7端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。

◆ 来看看指令and al，0x88。0x88的二进制形式是10001000，这意味着我们想用这条指令保留住寄存器AL中的第7位和第3位，其他无关的位都清零。此时，如果寄存器AL中的二进制数是00001000(0x08)，那就说明可以退出等待状态，继续往下操作，否则继续等待。

◆ 2024/02/02发表想法

读取硬盘扇区第五步

原文：第5步，连续取出数据。0x1f0是硬盘接口的数据端口，而且还是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。

◆ 0x1f1端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态（错误原因）。

◆ 过程(Procedure)又叫例程，或者子程序、子过程、子例程(Sub-routine)，不管怎么称呼，实质都一样，都是一段普通的代码。处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。

◆ 要调用过程，需要该过程的地址。一般来说，过程的第一条指令需要一个标号，以方便引用该过程。

◆ 编写过程的好处是只用编写一次，以后只需要“调用”即可。所以，代码的灵活性和通用性尤其重要。具体到这里，就是每次读硬盘时的起始逻辑扇区号和数据保存位置都不相同，这就涉及所谓的参数传递。

◆ 参数传递最简单的办法是通过寄存器。在这里，LBA扇区号是28位的，但寄存器的长度都是16位的，所以，主程序把起始逻辑扇区号分成高12位和低16位两部分，高12位左侧加0扩展到16位，存放在寄存器DI中，低16位存放在寄存器SI中，并约定将读出来的数据存放到由段寄存器DS指向的数据段中，起始偏移地址在寄存器BX中。

◆ 为了让主程序的执行不失连续性，在过程的开头，应当将本过程要用到（内容肯定会被破坏）的寄存器临时压栈，并在返回到调用点之前出栈恢复。

◆ 我们将把过程所在的标号作为过程的名字，即过程名。但是我们知道，它实际上代表过程的起始汇编地址。

◆ 第一种是16位相对近调用。近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，所以只需要得到偏移地址即可。16位相对近调用是三字节指令，操作码为0xE8，后跟16位的操作数，因为是相对调用，故该操作数是当前call指令相对于目标过程的偏移量。计算过程如下：用目标过程的汇编地址减去当前call指令的下一条指令的汇编地址，保留16位的结果。

◆ 近调用的特征是在指令中使用关键字“near”。

◆ 因为16位相对近调用的操作数是两个汇编地址相减的相对量，所以，如果被调用过程在当前指令的前方（指令执行的方向），也就是说，论汇编地址，它比call指令的要大，那么该相对量是一个正数；反之，就是一个负数。所以，它的机器指令操作数是一个16位的有符号数。换句话说，被调用过程的首地址必须位于距离当前call指令-32768～32767字节的地方。

◆ 标号是数值的等价形式，是代表标号处的汇编地址。在指令编译阶段，它首先会被转化成数值。

◆ 第二种是16位间接绝对近调用。这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址。不过，这个偏移地址不是直接出现在指令中的，而是由16位的通用寄存器或者16位的内存单元间接给出的。

◆ 第一条指令的机器码为FF D1，被调用过程的偏移地址位于寄存器CX内，在指令执行的时候由处理器从该寄存器取得，并直接取代指令指针寄存器IP原有的内容。第二条指令的机器码为FF 16 00 30。当这条指令执行时，处理器访问数据段（使用段寄存器DS），从偏移地址0x3000处取得一个字，作为目标过程的真实偏移地址，并用它取代指令指针寄存器IP原有的内容。

◆ 间接绝对近调用指令在执行时，处理器首先按以上的方法计算被调用过程的偏移地址，然后将指令指针寄存器IP的当前值压栈，最后用计算出来的偏移地址取代寄存器IP原有的内容。

◆ 由于间接绝对近调用的机器指令操作数是16位的绝对地址，因此，它可以调用当前代码段任何位置处的过程。

◆ 第三种是16位直接绝对远调用。这种调用属于段间调用，即调用另一个代码段内的过程，所以称为远调用(far call)。很容易想到，远调用既需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。

◆ “16位”是针对偏移地址来说的，而不是限定段地址，尽管段地址事实上也是16位的；“直接”的意思是，段地址和偏移地址直接在call指令中给出了。当然，这里的地址也是绝对地址。

◆ 这条指令编译后的机器码为9A 30 00 00 20，0x9A是操作码，后面跟着的两个字分别是偏移地址和段地址，按规定，偏移地址在前，段地址在后。

◆ 处理器在执行时，首先将代码段寄存器CS的当前内容压栈，接着再把指令指针寄存器IP的当前内容压栈。紧接着，用指令中给出的段地址代替CS原有的内容，用指令中给出的偏移地址代替指令指针寄存器IP原有的内容。这直接导致处理器从新的位置开始执行。

◆ 第四种是16位间接绝对远调用。这也属于段间调用，被调用过程位于另一个代码段内，而且，被调用过程所在的段地址和偏移地址是间接给出的。还有，这里的“16位”同样是用来限定偏移地址的。

◆ 间接远调用必须使用关键字“far”，这一点务必牢记。因为是远调用，也就是段间调用，所以，必须给出被调用过程的段地址和偏移地址。但是，段地址和偏移地址在内存中的其他位置，指令中仅仅给出的是该位置的偏移地址，需要处理器在执行指令的时候自行按图索骥，找到它们。

◆ “过程”就是例行公事，可以随时根据需要调用，但过程执行完了呢，还得返回到调用点继续执行下一条指令，这称为过程返回(Procedure Return)。

◆ ret和retf经常用作call和call far的配对指令。ret是近返回指令，当它执行时，处理器只做一件事，那就是从栈中弹出一个字到指令指针寄存器IP中。

◆ retf是远返回指令(return far)，它的工作稍微复杂一点点。当它执行时，处理器分别从栈中弹出两个字到指令指针寄存器IP和代码段寄存器CS中。

◆ call指令在执行过程调用时不影响任何标志位，ret/retf指令对标志位也没有任何影响。

◆ ![用户程序头部结构](image.png)

